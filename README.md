# ProfilerWithMat

# 内部类对外部类的持有导致内存泄漏，利用DDMS与MAT分析

参考了郭神的文章:
[Android最佳性能实践(二)——分析内存的使用情况](https://blog.csdn.net/guolin_blog/article/details/42238633)

每个程序都有可使用的内存上限，这被称为堆大小（heap size）

我们在开发应用程序时所使用的内存不能超过这个限制，否则就会出现OutOfMemoryError。

所以，我们的程序中需要缓存一些数据时，就可以根据堆大小来决定缓存数据的容量

Android 大概的GC流程：从一个叫做roots的对象开始检查，所有它可以访问到的对象就说明还在使用当中，应进行保存，而其它的对象就表示已经不再被使用了。

## Android中内存泄漏的问题：
Android中的垃圾回收机制并不能防止内存泄漏的出现，导致内存泄漏最主要的原因就是某些长存对象持有了一些其他应该被回收的对象的引用，导致垃圾回收期无法去回收掉这些对象，那也就出现了内存泄漏了。比如像activity这样的系统组件，它会包含很多的控件甚至是图片，如果它无法被垃圾回收器回收掉的话，就算比较严重的内存泄漏情况了。

如果我们在一个类中又定义了一个非静态的内部类，那么这个内部类就会持有外部类的引用。只要这个内部类的存活时间不会长于外部类，就不会阻止MainActivity被垃圾回收机回收。

## 使用DDMS与MAT遇到的问题：
从导出DDMS导出的hprof文件不能直接在MAT中使用，需要先将android的hprof文件进行转换：
将hprof文件导出至sdk的tools文件夹，cmd进入sdk的tools文件夹中，输入如下命令：
Hprof-conv -z xxx.hprof xxx_mat.hprof
然后就会在当前文件夹下创建出已转换好的hprof文件，在mat中打开此文件就行了。

## MAT两个常用工具：
Histogram:可以列出内存中每个对象的名字、数量以及大小。
Dominator tree:会将所有内存中的对象按大小进行排序，并且我们可以分析对象之间的引用结构。

### Dominator Tree:
界面右侧：
Retained heap表示这个对象以及它所持有的其他引用（包含直接和间接）所占的总内存。因此从上图中看，前两行的retained heap是最大的，我们分析内存泄漏时，内存最大的对象也是最应该去怀疑的。

界面左侧：
每一行最左边都有一个文件型的图标，一些图标的做小角带有一个红色的点。带红点的对象就表示是可以被GC访问到的，根据上面的讲解，可以被GC ROOT访问到的对象是无法被回收的。说明所有带红点的对象都是泄漏的对象吗？不是，因为有些对象系统需要一直使用，本来就不应该被回收。我们可以注意到，上图当中所有带红点的对象最右边都有些一个System Class.说明这是一个由系统管理的对象，并不是由我们自己创建并导致内存泄漏的对象。

从第一行即内存对象最多的入手：
对第一行右键->Path to GC Roots -> exclude weak references，即执行弱引用（赋值？）。弱引用是不会阻止对象被垃圾回收器回收的，所以我们这里直接进去查看。

通过这种方式，我们成功把内存泄漏的原因找出来了，这是dominator tree中比较常用的一种分析方式，即搜索大内存对象通向GC Roots的路径，因为内存占用越高的对象越值得怀疑。

### Histogram:
当前应用程序中所有的对象的名字、数量和大小全部都列出来。

Shallow heap概念:当前对象自己所占内存的大小，不包含引用关系。

我们可以通过donimator tree的方式找到内存泄漏的原因，但我们用更histogram的方式来找泄漏原因，比如histogram是可以显示对象的 数量的，我们猜测MainActiviy中有可能存在内存泄漏，我们就可以通过搜索的方式找到实例数量不正常的项列，从而找到内存泄漏的原因。


*DACHUNG*
*19-5-31*
